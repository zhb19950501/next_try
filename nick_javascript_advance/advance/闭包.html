<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script>
        /*
        如何产生闭包？
            当一个嵌套的内部（子）函数引用了桥套的外部（父）函数时，就产生了闭包
        闭包是什么？
            使用chrome调试查看
            理解一：闭包是嵌套的内部函数
            理解二：包含被引用变量（函数）的对象
            注意：闭包存在于嵌套的内部函数中
        产生闭包的条件
            函数嵌套
            内部函数引用了外部函数的数据（变量/函数）
                也就是内部函数需要被定义，也就是外部函数得被执行才行

        常见的闭包
            1、将函数作为另一个函数的返回值

            2、将函数作为实参传递给另一个函数调用

        闭包的作用
            1、使函数内部的变量在函数执行完后，仍然存活在内存中（延长了局部变量的生命周期）

            2、让函数外部可以操作（读写）到函数内部的数据（变量/函数）

            问题：
                1、函数执行完后，函数内部声明的局部变量是否存在？
                    一般是不存在，存在于闭包中的变量才可能存在
                2、在函数外部能直接访问函数内部的局部变量吗？
                    不能，但是我们可以通过闭包让外部操作它

        闭包的生命周期
            产生：在嵌套内部函数定义执行完时就产生了（不是在调用）
                定义执行！！！！就是定义这个过程执行了，函数提升就是定义过程，如果是用变量
                创建的函数，那就是在变量赋值完成的时候产生的

            死亡：在嵌套的内部函数称为垃圾对象时
            
        闭包的缺点
            函数执行完后，函数内部的局部变量没有释放，占用内存时间会变长
            容易造成内存泄漏
        闭包缺点的解决
            能不用就不用
            及时释放    

        内存溢出
            一种程序运行出现的错误
            当程序运行需要的内存超过了剩余的内存时，就抛出内存溢出的错误

        内存泄漏
            占用的内存没有及时释放
            内存泄漏积累多了就容易导致内存溢出
            常见的内存泄露
                意外的全局变量
                没有及时清理的计时器或回调函数
                闭包
        */ 

        function fn1(){
            var a = 2
            console.log(a)
            function fn2(){
                a ++
                console.log(a)
            }
            return fn2
        }

        var f = fn1()
        f() //3
        f() //4
        fn1() //2
        f = null//闭包死亡（包含闭包的函数对象成为垃圾对象）
    </script>
</head>
<body>
    
</body>
</html>